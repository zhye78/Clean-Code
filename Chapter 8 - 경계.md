# Chapter 8 - 경계

시스템에 들어가는 외부 소프트웨어를 사용할 때 그 경계를 깔끔하게 처리하는 기법을 살펴본다.

### 외부 코드 사용하기

 Java.util.Map을 살펴보면, 너무 많은 기능을 제공하기 때문에 여러 곳에서 사용할 때 위험이 크다.

 이 경우, 경계 인터페이스인 Map을 특정 클래스 안으로 숨겨 Map 인터페이스의 변경이 일어나더라도 나머지 프로그램에 영향을 미치지 않도록 하는 방법이 있다. 

```java
public class Sensors {
	private Map sensors = new HashMap();

	public Sensor getById(String id) {
		return (Sensor) sensors.get(id);
	}
}
```

 항상 이렇게 캡슐화하라는 소리가 아닌, Map같은 경계 인터페이스를 여기저기 무분별하게 넘기지 말자는 것.

### 경계 살피고 익히기

-**학습 테스트**: 외부 라이브러리를 사용할 때 우리 코드를 작성한 후 외부 코드를 호출하는 방법 대신, 간단한 테스트 케이스를 먼저 작성하여 외부 코드를 익히는 방법.

### log4j 익히기

 로깅 기능을 직접 구현하는 대신 아파치의 log4j 패키지를 사용한다고 했을 떄, 간단하게 콘솔 로거를 초기화하는 방법을 익히고, 그 지식들을 독자적인 로거 클래스로 캡슐화한다면 나머지 프로그램은 log4j 경계 인터페이스를 몰라도 된다.

### 학습 테스트는 공짜 이상이다.

 학습 테스트는 투자하는 노력보다 얻는 성과가 훨씬 크고, 외부 패키지/라이브러리/API의 새 버전에 대응하기가 쉬워진다.

### 아직 존재하지 않는 코드를 사용하기

 우리의 작업이 아닌 부분(저쪽 팀이 작업하는 부분)이 아직 진행중에 있어 존재하지 않을 떄, 우리가 바라는 인터페이스를 구현하고, 이후에 Adapter 패턴으로 API 사용을 캡슐화해 상대 팀의 작업물과의 간격을 메꾼다.

-**어댑터 패턴**: 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다. 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

### 깨끗한 경계

 소프트웨어의 경계에 위치하는 코드는 깔끔히 분리하고, 외부 패키지에 지나치게 의존하지 않도록 한다. 위의 Map 예제처럼 새 클래스로 경계를 감싸거나, 어댑터 패턴을 사용하여 외부 패키지 호출 코드를 가능한 줄여 경계를 관리해야 코드 가독성이 높아지며, 외부 패키지 변경에 대응도 쉬워진다.